python -m venv venv     sudo apt-get install -y python3-venv + python3 -m venv venv
pip install --upgrade pip
pip install django
python -m pip install django-filter==21.1
pip install django-allauth
pip install apscheduler      pip install django-apscheduler
pip3 install celery
pip install flake8
pip install django-modeltranslation
pip install django-email-verification


Далее нам нужно настроить поддержку Redis в Python и Celery. Вновь зайдите в виртуальное окружение и установите следующие пакеты:
pip3 install redis
pip3 install -U "celery[redis]"



venv\scripts\activate   source venv/bin/activate
cd NewsPaper
cd project
cd mcdonalds

python3 manage.py migrate
python3 manage.py runserver
python3 manage.py makemigrations
python3 manage.py shell
quit()
python3 manage.py runapscheduler

python3 manage.py makemessages -l ru
python3 manage.py compilemessages


Для запуска задач по расписанию, а именно это нам и понадобится сейчас, необходимо запускать Celery с флагом -B, который позволяет запускать периодические задачи:
$ celery -A NewsPaper worker -l INFO -B

celery -A mcdonalds worker -l INFO

Также обратите внимание, что Celery с версией выше 4+ не поддерживается Windows. Поэтому если у вас версия Python 3.10 и выше, запускайте Celery, добавив в команду флаг: --polo=solo.
celery -A mcdonalds worker -l INFO --polo=solo
redis-cli ping
redis-server


django-admin startproject имя проекта   #создание нового проекта
python3 manage.py startapp sign      #создания нового приложения в проекте



Итого мы вырезали лишнее из шаблона index.html, из архива мы ещё добавили специальные теги для поиска статических
файлов. Дело в том, что изначально в шаблоне был указан абсолютный путь, предполагая, что он лежит в той же папке где и
все статические файлы. Но поскольку мы перенесли шаблон в нашу папку flatpages/default.html, а все остальные файлы
 остались лежать там же, где и были, мы можем прописать статический путь так, чтобы потом не приходилось его везде
 менять, если он вдруг изменится, как мы это делали минуту назад с шаблонами. Для этого надо в самом начале HTML-файла
 дописать {% load static %}, чтобы получить доступ к статическим файлам. И перед каждой гиперссылкой или ресурсом надо
 просто писать тег {% static %}, а сам путь взять в кавычки. Таким образом Django сам поможет нам и подставит путь к
 статическим файлам за нас. Никаких абсолютных путей — чудесно!


P.S. Если вы вдруг испытываете трудности с подгонкой шаблона под ваш проект, то вы в любой момент можете пройти по
ссылке на GitHub и склонировать полностью рабочий репозиторий.
https://github.com/SkillfactoryCoding/django_tutorial



После установки Django создаём пустой проект:
django-admin startproject project

После того как наша база данных заработала (и появилось место для хранения информации), мы можем создать нашего первого
администратора. У админа должен быть свой логин и пароль для входа в систему. Давайте его создадим командой:
python manage.py createsuperuser

django-admin help
Выполните django-admin help для отображения информации об использовании и списка команд, предоставляемых каждым приложением.
Выполните django-admin help --commands, чтобы отобразить список всех доступных команд.
Выполните django-admin help <command>, чтобы вывести описание заданной команды и список ее доступных опций.


python manage.py check. Эта команда проверяет любые проблемы в вашем проекте, не делая миграции или касаясь базы данных.


Alt+Ctrl+L исправление найденных ошибок по PEP8

flake8 my_project  - запуск для проекта либо просто flake8 для всей папки
flake8 --select E123  - проверять только одно правило

Файл конфигурации для flake8:
настройка возможна с помощью конфигурационных файлов setup.cfg, tox.ini или .flake8

Пример файла:

[flake8]
ignore = D203  #игнор правил
exclude = .git #игнор файлов и каталогов

для игнорирования строки в коде нужно добавить коментарий # noqa:
import sys # noqa

Модули расширяющие функциональность flake8:
pip install flake8-import-order
flake8-import-order -плагин проверяющий порядок импортов в проекте

[flake8]
application-import-names = my_project, tests  #указываем флейку директории в которых
# хранится локальные паеты (директории к которым хотим применить плагин)
import-order-style = google # указываем флейку на то в каком порядке должны идти импорты

flake8-docstrings
- плагин добавляющий поддержку функционала из pydocstyle проверку докстрингов
на соответствие конвенциям питона
pip install flake8_docstrings

-----------------------------------
Межсайтовая подделка запросов (CSRF)
Для защиты от таких действий служит CSRF Token. Это уникальная строка, состоящая из букв и цифр, которая передаётся от
сервера к пользователю и возвращается серверу после заполнения формы. Если сервер получил данные формы без этого токена,
то он отклоняет её. Конечно и этот уникальный токен можно получить, но тогда снижается характер массовости такой атаки.
Защита от CSRF-атак включена в Django по умолчанию. Разработчику следует только использовать в шаблонах тег:

{% csrf_token %}
------------------------------------
Безопасный протокол передачи (HTTPS)
Django позволяет использовать HTTPS и предоставляет следующие методы защиты:

SECURE_PROXY_SSL_HEADER
Используется для проверки, что подключение всегда безопасное, даже если данные поступают из небезопасного (HTTP) прокси.
SECURE_SSL_REDIRECT
Используется для перенаправления всех запросов с HTTP на HTTPS. Это обсуждалось ранее.
SESSION_COOKIE_SECURE/CSRF_COOKIE_SECURE
Флаги, которые жёстко устанавливают передачу данных cookie только через протокол HTTPS.
ALLOWED_HOSTS
Список доверенных хостов.
------------------------------------
Другие методы защиты
Если не вдаваться в технические подробности реализации методов защиты, то можно лишь сказать, что фреймворк позволяет
 усилить защиту для следующих атак:

1.SQL injection
Защита от такого вида атак достигается использованием Django ORM. Они, можно сказать, экранируют прямое написание
SQL-запросов от пользователя. Конечно, существуют способы «ручного» написания запросов, и с ними нужно быть осторожными,
 но это более редкая возможность.
2. Clickjaking
Для обеспечения защиты от перехвата кликов, Django использует промежуточное программное обеспечение (middleware),
который поддерживается браузерами. Его цель — запрет отображения скрытых элементов на страницах, которые как раз и
служат основой для кликджекинга.
3. Подделка контента и загрузка небезопасного контента.
В Django реализована проверка загружаемого контента (например, изображений) с помощью встроенных классов
(FileField, ImageField). Также есть возможности для ограничения размеров загрузок, что также позволяет защититься от
DoS-атак.
И более того, Django содержит один полезный инструмент для проверки безопасности вашего приложения на основные угрозы.

Из корня приложения можно запустить команду:

python3 manage.py check --deploy
Результатом её выполнения является анализ приложения на наличие ошибок, угроз безопасности и др. Использование этой
команды может быть также полезным при рассмотрении вашего приложения с точки зрения безопасности.
***************************************************

Давайте попробуем выгрузить все записи из нашей БД в JSON-файл:
python manage.py dumpdata --format=json > mydata.json

давайте попробуем выгрузить наши данные, но уже в другом формате:
python manage.py dumpdata --format=xml > mydata.xml

Так, ну и теперь попробуем удалить данные через админ-панель и снова загрузить их, но уже через команду loaddata:
python manage.py loaddata mydata.json

В итоге у нас должно появится следующее сообщение в консоли:
Installed 3 object(s) from 1 fixture(s)
Это говорит о том, что данные снова загрузились успешно! (Постарайтесь, чтобы в ваших объектах не было полей с русскими
буквами, иначе можно жёстко застрять с кодировкой

Последние две команды могут служить для самых разных целей, но, как правило, в большинстве случаев, они используются
для создания тестовых данных. Например, данных для базы данных тестового сервера или же фикстур для тестов (тесты мы
затронем немножко попозже, но это тоже довольно интересная вещь). Также необязательно выгружать целиком данные из всего
проекта, можно выгрузить данные из какого-то одного приложения, для этого достаточно добавить аргумент с названием
приложения:
python manage.py dumpdata --format=xml sample_app > sampledata.xml

Параметр --database может указывать на базу данных (названия берутся из настроек), из которой будут выгружаться или в
которую будут загружаться данные, на случай если у вас их несколько.

Ну и команда экстерминатус — полная очистка базы данных, т. е. удаление всех данных из таблиц в ней.
python manage.py flush

Если у вас несколько баз данных, то можно указать всё тот же параметр --database и очистить какую-то конкретную БД.

